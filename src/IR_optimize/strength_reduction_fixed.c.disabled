//
// Created by Assistant
// 强度削减优化 (Strength Reduction Optimization)
// 将派生归纳变量的乘法操作替换为增量操作
//

#include "include/induction_variable_analysis.h"
#include "include/loop_analysis.h"
#include <IR.h>
#include <stdio.h>
#include <stdlib.h>
#include <container/list.h>
#include <container/treap.h>

// 前向声明辅助函数
static void replace_variable_in_stmt(IR_stmt *stmt, IR_var old_var, IR_var new_var);
static void replace_variable_in_IR_val(IR_val *val, IR_var old_var, IR_var new_var);

/**
 * @brief 为派生归纳变量创建强度削减变量
 * @param derived_iv 派生归纳变量
 * @return 新创建的强度削减变量
 */
StrengthReductionVariable_ptr create_strength_reduction_variable(DerivedInductionVariable_ptr derived_iv) {
    if (!derived_iv) return NULL;
    
    StrengthReductionVariable_ptr sr_var = malloc(sizeof(StrengthReductionVariable));
    if (!sr_var) return NULL;
    
    // 分配新的变量
    sr_var->new_variable = ir_var_generator();
    sr_var->original_variable = derived_iv->variable;
    sr_var->increment_value = derived_iv->coefficient * derived_iv->basic_iv->step;
    sr_var->initialization_stmt = NULL;
    sr_var->increment_stmt = NULL;
    
    printf("Created strength reduction variable v%u for v%u (increment: %d)\n",
           sr_var->new_variable,
           derived_iv->variable,
           sr_var->increment_value);
    
    return sr_var;
}

/**
 * @brief 在循环前序块中创建初始化语句
 * @param sr_var 强度削减变量
 * @param derived_iv 派生归纳变量
 * @param loop 循环
 */
void create_initialization_in_preheader(StrengthReductionVariable_ptr sr_var, 
                                       DerivedInductionVariable_ptr derived_iv, 
                                       Loop_ptr loop) {
    if (!sr_var || !derived_iv || !loop || !loop->preheader) return;
    
    // 创建初始化赋值语句：sr_var = coefficient * basic_iv + constant
    // 如果 coefficient == 1，直接创建: sr_var = basic_iv + constant
    // 否则先创建: tmp = coefficient * basic_iv, 然后 sr_var = tmp + constant
    
    if (derived_iv->coefficient == 1) {
        // 简单情况：sr_var = basic_iv + constant
        if (derived_iv->constant == 0) {
            // sr_var = basic_iv
            IR_val basic_iv_val = {.is_const = false, .var = derived_iv->basic_iv->variable};
            IR_assign_stmt *assign_stmt = (IR_assign_stmt*)malloc(sizeof(IR_assign_stmt));
            IR_assign_stmt_init(assign_stmt, sr_var->new_variable, basic_iv_val);
            sr_var->initialization_stmt = (IR_stmt*)assign_stmt;
        } else {
            // sr_var = basic_iv + constant
            IR_val basic_iv_val = {.is_const = false, .var = derived_iv->basic_iv->variable};
            IR_val constant_val = {.is_const = true, .const_val = derived_iv->constant};
            IR_op_stmt *op_stmt = (IR_op_stmt*)malloc(sizeof(IR_op_stmt));
            IR_op_stmt_init(op_stmt, IR_OP_ADD, sr_var->new_variable, basic_iv_val, constant_val);
            sr_var->initialization_stmt = (IR_stmt*)op_stmt;
        }
    } else {
        // 复杂情况：需要先计算 coefficient * basic_iv
        IR_var temp_var = ir_var_generator();
        
        // temp_var = coefficient * basic_iv
        IR_val coeff_val = {.is_const = true, .const_val = derived_iv->coefficient};
        IR_val basic_iv_val = {.is_const = false, .var = derived_iv->basic_iv->variable};
        IR_op_stmt *mul_stmt = (IR_op_stmt*)malloc(sizeof(IR_op_stmt));
        IR_op_stmt_init(mul_stmt, IR_OP_MUL, temp_var, coeff_val, basic_iv_val);
        
        // 将乘法语句添加到前序块
        VCALL(loop->preheader->stmts, push_back, (IR_stmt*)mul_stmt);
        
        if (derived_iv->constant == 0) {
            // sr_var = temp_var
            IR_val temp_val = {.is_const = false, .var = temp_var};
            IR_assign_stmt *assign_stmt = (IR_assign_stmt*)malloc(sizeof(IR_assign_stmt));
            IR_assign_stmt_init(assign_stmt, sr_var->new_variable, temp_val);
            sr_var->initialization_stmt = (IR_stmt*)assign_stmt;
        } else {
            // sr_var = temp_var + constant
            IR_val temp_val = {.is_const = false, .var = temp_var};
            IR_val constant_val = {.is_const = true, .const_val = derived_iv->constant};
            IR_op_stmt *add_stmt = (IR_op_stmt*)malloc(sizeof(IR_op_stmt));
            IR_op_stmt_init(add_stmt, IR_OP_ADD, sr_var->new_variable, temp_val, constant_val);
            sr_var->initialization_stmt = (IR_stmt*)add_stmt;
        }
    }
    
    // 将初始化语句添加到前序块
    VCALL(loop->preheader->stmts, push_back, sr_var->initialization_stmt);
    
    printf("Added initialization for v%u in preheader\n", sr_var->new_variable);
}

/**
 * @brief 在循环内创建增量语句
 * @param sr_var 强度削减变量
 * @param loop 循环
 */
void create_increment_in_loop(StrengthReductionVariable_ptr sr_var, Loop_ptr loop) {
    if (!sr_var || !loop) return;
    
    // 在循环的最后一个块中创建增量语句：sr_var = sr_var + increment_value
    // 找到循环的最后一个基本块
    IR_block *last_block = NULL;
    for_list(IR_block_ptr, i, loop->blocks) {
        last_block = i->val;
    }
    
    if (!last_block) return;
    
    // 创建增量语句
    IR_val sr_var_val = {.is_const = false, .var = sr_var->new_variable};
    IR_val increment_val = {.is_const = true, .const_val = sr_var->increment_value};
    
    IR_op_stmt *inc_stmt = (IR_op_stmt*)malloc(sizeof(IR_op_stmt));
    IR_op_stmt_init(inc_stmt, IR_OP_ADD, sr_var->new_variable, sr_var_val, increment_val);
    sr_var->increment_stmt = (IR_stmt*)inc_stmt;
    
    // 将增量语句添加到最后一个块的末尾（在跳转语句之前）
    // 需要找到合适的位置插入
    if (last_block->stmts.tail == NULL) {
        // 空块，直接添加
        VCALL(last_block->stmts, push_back, sr_var->increment_stmt);
    } else {
        IR_stmt *last_stmt = last_block->stmts.tail->val;
        if (last_stmt->stmt_type == IR_GOTO_STMT || last_stmt->stmt_type == IR_IF_STMT) {
            // 在跳转语句之前插入
            ListNode_IR_stmt_ptr *new_node = (ListNode_IR_stmt_ptr*)malloc(sizeof(ListNode_IR_stmt_ptr));
            new_node->val = sr_var->increment_stmt;
            new_node->nxt = last_block->stmts.tail;
            new_node->prev = last_block->stmts.tail->prev;
            
            if (last_block->stmts.tail->prev) {
                last_block->stmts.tail->prev->nxt = new_node;
            } else {
                last_block->stmts.head = new_node;
            }
            last_block->stmts.tail->prev = new_node;
        } else {
            // 直接添加到末尾
            VCALL(last_block->stmts, push_back, sr_var->increment_stmt);
        }
    }
    
    printf("Added increment for v%u in loop\n", sr_var->new_variable);
}

/**
 * @brief 替换派生变量的使用
 * @param sr_var 强度削减变量
 * @param derived_iv 派生归纳变量
 * @param loop 循环
 */
void replace_derived_variable_uses(StrengthReductionVariable_ptr sr_var,
                                 DerivedInductionVariable_ptr derived_iv,
                                 Loop_ptr loop) {
    if (!sr_var || !derived_iv || !loop) return;
    
    printf("  Replacing uses of v%u with v%u in loop\n",
           derived_iv->variable,
           sr_var->new_variable);
    
    // 遍历循环中的所有块和语句，替换对derived_iv->variable的使用
    for_list(IR_block_ptr, block_i, loop->blocks) {
        IR_block *block = block_i->val;
        if (!block) continue;
        
        // 遍历基本块中的所有语句
        for_list(IR_stmt_ptr, stmt_i, block->stmts) {
            IR_stmt *stmt = stmt_i->val;
            
            // 跳过定义语句本身
            if (stmt == derived_iv->definition_stmt) {
                continue;
            }
            
            // 替换语句中对derived_iv->variable的使用
            replace_variable_in_stmt(stmt, derived_iv->variable, sr_var->new_variable);
        }
    }
    
    printf("  Completed variable replacement\n");
}

/**
 * @brief 对循环执行强度削减优化
 */
void perform_strength_reduction(LoopInductionVariables_ptr loop_ivs) {
    if (!loop_ivs || !loop_ivs->derived_ivs.head) return;
    
    printf("\n=== Performing Strength Reduction for Loop ===\n");
    
    // 为每个派生归纳变量创建强度削减变量
    for (ListNode_DerivedInductionVariable_ptr *div_node = loop_ivs->derived_ivs.head;
         div_node != NULL; div_node = div_node->nxt) {
        
        DerivedInductionVariable_ptr derived_iv = div_node->val;
        
        // 只对系数不为1的派生归纳变量进行强度削减
        if (derived_iv->coefficient == 1) {
            printf("Skipping strength reduction for v%u (coefficient = 1)\n",
               derived_iv->variable);
            continue;
        }
        
        printf("Processing derived induction variable v%u = %d * v%u + %d\n",
               derived_iv->variable,
               derived_iv->coefficient,
               derived_iv->basic_iv->variable,
               derived_iv->constant);
        
        // 创建强度削减变量
        StrengthReductionVariable_ptr sr_var = create_strength_reduction_variable(derived_iv);
        if (!sr_var) continue;
        
        // 在前序块中创建初始化
        create_initialization_in_preheader(sr_var, derived_iv, loop_ivs->loop);
        
        // 在循环体中创建增量更新
        create_increment_in_loop(sr_var, loop_ivs->loop);
        
        // 替换原变量的使用
        replace_derived_variable_uses(sr_var, derived_iv, loop_ivs->loop);
        
        // 将强度削减变量添加到列表中
        ListNode_StrengthReductionVariable_ptr *sr_node = malloc(sizeof(ListNode_StrengthReductionVariable_ptr));
        sr_node->val = sr_var;
        sr_node->nxt = NULL;

        loop_ivs->
        
        if (loop_ivs->strength_reduction_vars.tail) {
            loop_ivs->strength_reduction_vars.tail->nxt = sr_node;
            loop_ivs->strength_reduction_vars.tail = sr_node;
        } else {
            loop_ivs->strength_reduction_vars.head = sr_node;
            loop_ivs->strength_reduction_vars.tail = sr_node;
        }
    }
    
    printf("=== Strength Reduction Complete ===\n\n");
}

/**
 * @brief 对单个函数的所有循环执行强度削减
 */
void perform_strength_reduction_for_function(IR_function *function, LoopAnalyzer *loop_analyzer) {
    if (!function || !loop_analyzer) return;
    
    printf("=== Starting Strength Reduction for Function: %s ===\n", function->func_name);
    
    // 执行归纳变量分析
    InductionVariableAnalyzer iv_analyzer;
    InductionVariableAnalyzer_init(&iv_analyzer, function, loop_analyzer);
    InductionVariableAnalyzer_analyze(&iv_analyzer);
    
    // 对每个循环执行强度削减
    for (int i = 0; i < List_Loop_ptr_size(loop_analyzer->all_loops); i++) {
        Loop_ptr loop = List_Loop_ptr_get(loop_analyzer->all_loops, i);
        
        // 获取循环的归纳变量信息
        LoopInductionVariables_ptr loop_ivs = InductionVariableAnalyzer_get_loop_ivs(&iv_analyzer, loop);
        if (!loop_ivs || !loop_ivs->derived_ivs.head) {
            printf("No derived induction variables found in loop %p\n", loop);
            continue;
        }
        
        printf("Performing strength reduction for loop %p\n", loop);
        
        // 执行强度削减
        perform_strength_reduction(loop_ivs);
    }
    
    InductionVariableAnalyzer_teardown(&iv_analyzer);
    printf("=== Strength Reduction Complete for Function: %s ===\n", function->func_name);
}

/**
 * @brief 在语句中替换变量使用
 */
static void replace_variable_in_stmt(IR_stmt *stmt, IR_var old_var, IR_var new_var) {
    if (!stmt) return;
    
    switch (stmt->stmt_type) {
        case IR_OP_STMT: {
            IR_op_stmt *op_stmt = (IR_op_stmt*)stmt;
            replace_variable_in_IR_val(&op_stmt->rs1, old_var, new_var);
            replace_variable_in_IR_val(&op_stmt->rs2, old_var, new_var);
            break;
        }
        case IR_ASSIGN_STMT: {
            IR_assign_stmt *assign_stmt = (IR_assign_stmt*)stmt;
            replace_variable_in_IR_val(&assign_stmt->rs, old_var, new_var);
            break;
        }
        case IR_LOAD_STMT: {
            IR_load_stmt *load_stmt = (IR_load_stmt*)stmt;
            replace_variable_in_IR_val(&load_stmt->rs_addr, old_var, new_var);
            break;
        }
        case IR_STORE_STMT: {
            IR_store_stmt *store_stmt = (IR_store_stmt*)stmt;
            replace_variable_in_IR_val(&store_stmt->rd_addr, old_var, new_var);
            replace_variable_in_IR_val(&store_stmt->rs, old_var, new_var);
            break;
        }
        case IR_IF_STMT: {
            IR_if_stmt *if_stmt = (IR_if_stmt*)stmt;
            replace_variable_in_IR_val(&if_stmt->rs1, old_var, new_var);
            replace_variable_in_IR_val(&if_stmt->rs2, old_var, new_var);
            break;
        }
        case IR_RETURN_STMT: {
            IR_return_stmt *return_stmt = (IR_return_stmt*)stmt;
            replace_variable_in_IR_val(&return_stmt->rs, old_var, new_var);
            break;
        }
        case IR_CALL_STMT: {
            IR_call_stmt *call_stmt = (IR_call_stmt*)stmt;
            for (unsigned i = 0; i < call_stmt->argc; i++) {
                replace_variable_in_IR_val(&call_stmt->argv[i], old_var, new_var);
            }
            break;
        }
        case IR_WRITE_STMT: {
            IR_write_stmt *write_stmt = (IR_write_stmt*)stmt;
            replace_variable_in_IR_val(&write_stmt->rs, old_var, new_var);
            break;
        }
        default:
            break;
    }
}

/**
 * @brief 在IR_val中替换变量使用
 */
static void replace_variable_in_IR_val(IR_val *val, IR_var old_var, IR_var new_var) {
    if (!val || val->is_const) return;
    
    if (val->var == old_var) {
        val->var = new_var;
        printf("    Replaced variable use: v%u -> v%u\n", old_var, new_var);
    }
}
